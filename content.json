{"meta":{"title":"Air's Notebook","subtitle":"Just notebook","description":"Just notebook","author":"Air","url":"http://yoursite.com","root":"/"},"pages":[{"title":"categories","date":"2020-06-05T01:09:59.000Z","updated":"2020-06-05T01:10:32.271Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2020-06-05T01:09:09.000Z","updated":"2020-06-05T01:10:46.275Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"qtcp","slug":"qtcp","date":"2020-06-06T14:28:05.000Z","updated":"2020-06-06T14:39:42.712Z","comments":true,"path":"2020/06/06/qtcp/","link":"","permalink":"http://yoursite.com/2020/06/06/qtcp/","excerpt":"","text":"QTCP: Adaptive Congestion Control with Reinforcement Learning IEEE Transactions on Network Science and Engineering ¶ Model Q-learning + Kanerva Coding ¶ State average packet sending interval average consecutive ACK received interval average RTT Kanerva Coding :question: work as a function approximation to reducing the huge, continous state space ¶ Action increase: +10, decrease: -1, Keep: 0 ¶ Reward Utility = $\\alpha \\times \\log{throughput} - \\sigma \\times \\log{RTT}$ reward = $a (a &gt; 0)$, if $U’ &gt; \\epsilon$ $b (b &lt; 0)$, if $U’ &lt; -\\epsilon$ ¶ Training Online! ¶ Parameters Parameters Value Learning rate $\\alpha$ 0.95, *0.995 per second Exploration rate 0.1, *0.9995 per second Discount factor $\\gamma$ 0.9 Reward update time 0.23 s Simulation time 800 s RTT 120 ms buffer size 200 packet Generalization tolerance factor $\\beta$ 0.8 ¶ Environment setting NS-3 Simulator 2 Senders $\\leftrightarrow$ Router $\\leftarrow$ wireless $\\rightarrow$ Router $\\leftrightarrow$ 2 Reciever ¶ Fixed bandwidth 40 Mbps 65%](fixed_bandwidth_throughput.png) ![65% ¶ Dynamic bandwidth 60 Mbps, 40s $\\to$ 30 Mbps, 10s $\\to …$ 110%](dynamic_bandwidth_throughput.png) ![110%","categories":[],"tags":[{"name":"reinforcement learning","slug":"reinforcement-learning","permalink":"http://yoursite.com/tags/reinforcement-learning/"},{"name":"tcp","slug":"tcp","permalink":"http://yoursite.com/tags/tcp/"},{"name":"congestion control","slug":"congestion-control","permalink":"http://yoursite.com/tags/congestion-control/"}]},{"title":"Multi-Path TCP RL","slug":"Multi-Path-TCP-RL","date":"2020-06-06T14:22:29.000Z","updated":"2020-06-06T14:25:24.497Z","comments":true,"path":"2020/06/06/Multi-Path-TCP-RL/","link":"","permalink":"http://yoursite.com/2020/06/06/Multi-Path-TCP-RL/","excerpt":"","text":"Experience-Driven Congestion Control: When Multi-Path TCP Meets Deep Reinforcement Learning IEEE Journal of Selected Areas in Communications (JSAC) ¶ Overview Scenario: Multi-Path TCP One RL agent $\\longleftrightarrow$ MPTCP flows on an end host Implemented on Linux kernel Policy gradient, Actor-Critic LSTM Setting of testing scenario ¶ Model Flows $\\to$ LSTM $\\to$ RL 90% ¶ LSTM state of all flows $s_t = [s_t^1, …, s_t^N] \\to$ one output 90% ¶ State Flow(total: $N$): $i$, subflow(total: $K_i$): $k$, epoch: $t$ Agent $\\to$ Flows(TCP &amp; MPTCP) $\\to$ Subflows(only 1 if is regular TCP) $s_t^{i, k} = [b, g, d, v, w]$ corresponding sending rate goodput average RTT mean deviation of RTTs respective cwnd $s_t = [s_t^1, …, s_t^N]$ $s_t^i = [s_t^{i, 1}, …, s_t^{i, K_i}]$ ¶ Action $a_t = [x_t^1, …, x_t^K]$ $x_i$: changes to current subflows’ cwnd DRL-CC only takes an action on one (target) MPTCP flow ¶ Reward $r_t = \\sum_{i = 1 \\to N}{U(i, t)}$ U depends on upper-layer apps in paper: $U=\\lg{g_t^i}$ ($g_t$: average goodput during the $t-1$ epoch) maximizing this utility function leads to proportional fairness (Why?) ¶ Training ¶ Pre-training Environment using iPerf3 to continuously generate packets 2 laptop $\\longleftarrow$ Gigabit switch $\\longrightarrow$ 2 server 1 MPTCP = 2 subflow: 8Mbps, 200ms, 0.5% 50000 epochs 2.5 hours ¶ Online Test Benchmark Jain’s fairness index: $\\bar{x}^2 / \\bar{x^2}$ goodput General Environment client $\\longleftarrow$ 5 MPTCP flows $\\longrightarrow$ server transporting document through HTTP / iPerf3 0.5ms to convergence Parameters delay: $50ms \\to 400ms$ packet loss rate: $0.5% \\to 4%$ bottleneck bandwidth: $2Mbps \\to 16Mbps$ document: 2 $\\to$ 8 MB Scenerios 4 (HTTP) + 3 (iPerf3) + 1 (wireless) 5-th: dynamic establishments and terminations of MPTCP flows establish: Poisson process, each flow lasted for 30s 6-th: 5 MPTCP in begining, close 1 subflow per 60s 7-th: MPTCP and TCP co-exist $\\to$ TCP-friendliness 9-th: wireless environment","categories":[],"tags":[{"name":"reinforcement learning","slug":"reinforcement-learning","permalink":"http://yoursite.com/tags/reinforcement-learning/"},{"name":"tcp","slug":"tcp","permalink":"http://yoursite.com/tags/tcp/"},{"name":"congestion control","slug":"congestion-control","permalink":"http://yoursite.com/tags/congestion-control/"}]},{"title":"Side Window Filtering","slug":"Side-Window-Filtering","date":"2020-06-06T12:58:38.000Z","updated":"2020-06-06T13:08:22.488Z","comments":true,"path":"2020/06/06/Side-Window-Filtering/","link":"","permalink":"http://yoursite.com/2020/06/06/Side-Window-Filtering/","excerpt":"","text":"发表在 CVPR 2019 Oral [1] 原文 pdf 链接 作者在知乎上的介绍 ¶ Algorithm give $I$ such that minimize cost function $E$. where $I = \\frac{1}{N_n} \\sum{\\omega \\cdot q}$ $E = || q - I ||_2^2$ possible windows: $S = {L, R, U, D, NW, NE, SW, SE}$ input of pixel: $q$, output of pixel: $I$ local window: $\\Omega$, pixel in window $\\Omega$: $q$, kernel_weight: $\\omega$ ¶ Background ¶ Edge-preserving filters Two categories ¶ global optimization based algorithms total variation (TV) algorithm iterative shrinkage approach relative total variation algorithm weighted least squares algorithm ¶ local optimization based algorithms bilateral filter 双边滤波器[2] bilateral filter accelerated versions guided filter 导向滤波 guided filter extensions rolling guidance filter mutual structure joint filtering curvature filter[3] ¶ Filtering Fundamentals ¶ common assume image is piecewise linear approximate a pixel as the weighted average of its neighbor pixels over a local window $$ I_i’ = \\sum_{j \\in \\Omega_i} \\omega_{ij} q_j $$ ¶ cost function $$ E_i = { {|| I_i - I_i’ ||}_2 }^2 $$ $$ = (I_i - \\sum_{j \\in \\Omega_i} \\omega_{ij} q_j) ^ 2 $$ ¶ trade off manipulating the input image towards a desired target 去噪声 keeping it close to the original 保真 ¶ Type of typical edges [4] step edge 12345 ┌───── │ │ │─────┘ ramp edge 12345 ┌───── &#x2F; &#x2F; &#x2F;─────┘ roof edge 12345 &#x2F;\\ &#x2F; \\ &#x2F; \\ &#x2F; \\&#x2F; \\ line edge 12345 ┌─┐ │ │ │ │ │ │─────┘ └───── 这些函数是连续但不可导的（考虑$|x|$） ¶ Anything 1.2. Problem and Motivation 部分用 $g(x, y)$ 和 Taylor expansion 来说明在边缘处，两侧点的取值差距较大。因此跳跃点两侧应当分开来进行考虑。 ¶ Definition of side window 2. Side Window Filtering Technique 中对参数 $\\varphi$ 的说明不足。如下图所示，论文中认为 $OD$ 是定长 $r$，矩形 $Q$ 是固定的；而 $OA$ 为变长 $\\varphi$，矩形 $P$ 是可伸缩的 12345A┌─────┐B │ P │O├─────┤E │ Q │D└─────┘C 论文中认为 $OE$ 线条的宽度为 $1$ 像素，而其他线条宽度为 $0$ ¶ I Don’t Understand It is worth noting that optimization problem of the form similar to eq. (2) is found in many applications including coloriza- tion [14][22] and image segmentation [25][28], where the weight functions are usually referred to as affinity functions. Nonlinear approximation filtering such as median filtering can also be formulated as a similar form of optimization problem What is Oral? ↩︎ https://zh.wikipedia.org/zh-cn/双边滤波器 ↩︎ https://github.com/YuanhaoGong/CurvatureFilter ↩︎ https://www.researchgate.net/figure/Type-of-Edges-a-Step-Edge-b-Ramp-Edge-c-Line-Edge-d-Roof-Edge_fig1_228349759 ↩︎","categories":[],"tags":[{"name":"computer vision","slug":"computer-vision","permalink":"http://yoursite.com/tags/computer-vision/"},{"name":"denoise","slug":"denoise","permalink":"http://yoursite.com/tags/denoise/"},{"name":"filter","slug":"filter","permalink":"http://yoursite.com/tags/filter/"}]},{"title":"Side Window Filtering 调研报告","slug":"Side-Window-Filtering-调研报告","date":"2020-06-06T12:49:23.000Z","updated":"2020-06-06T13:05:08.403Z","comments":true,"path":"2020/06/06/Side-Window-Filtering-调研报告/","link":"","permalink":"http://yoursite.com/2020/06/06/Side-Window-Filtering-%E8%B0%83%E7%A0%94%E6%8A%A5%E5%91%8A/","excerpt":"","text":"这是计算机视觉的课程作业 ¶ Introduction ¶ Background 图像滤波在图像处理领域十分重要。数十年来，有许多的滤波算法/滤波器被提出，他们被广泛用于图像去模糊、图像锐化、边缘检测和特征提取。 有许多应用用到了滤波器的一个重要特性——边缘保留（edge-preserving）。边缘保留希望图像中的边缘在经过滤波器处理后能尽可能得被保留下来，不至于显得过于模糊。这一类滤波器通常可以被分为两类， 一类是全局优化性算法（global optimization based algorithms），比如total variation算法，iterative shrinkage approach算法，relative total variation算法，weighted least squares算法； 另一类是局部优化性算法（local optimization based algorithms），例如双边滤波算法（Bilateral Filters），导向滤波算法，mutual structure joint算法，curvature算法。 下面我们讨论局部优化性的滤波算法。这类算法通常是输入一个中心像素以及它的一些邻近像素，然后输出一个处理后的结果像素。这其中的处理过程，有线性的处理方式，例如均值滤波、高斯滤波，也有非线性的处理方式，例如中值滤波、双边滤波。下面我们考虑线性的局部优化滤波器。 线性的局部优化滤波器通常有以下两个假设 图像是分段局部（piecewice）线性的 算法的输出是原像素在一个局部窗口中的邻近像素的加权和。如果用式子表示即： $$ I_i’ = \\sum_{j \\in \\Omega_i} \\omega_{ij} q_j $$ 其中 $i$ 是原像素在原图像中的坐标，$I_i’$是输出像素，$\\omega_i$ 是局部窗口， $j$ 是邻近像素 $q$ 在局部窗口 $\\omega$ 中的坐标， $q_j$ 是邻近像素， $\\omega_{ij}$ 是邻近像素 $q_{ij}$ 在窗口中被赋予的权值。 而滤波器输出的结果与原图像之间的差异通常用以下用二范数表示的损失函数（lost function）来描述： $$ E_i = {|| I_i - I_i’ ||}_2^2 $$ 具体到线性的局部优化滤波器的情况，这个式子为 $$ E_i = {(I_i - \\sum_{j \\in \\Omega_i} \\omega_{ij} q_j)}^ 2 $$ ¶ Problem and Motivation 对于线性局部优化滤波器，我们考虑如下图所示的三种“边缘”：阶梯形边缘（step edge），坡形边缘（ramp edge），屋顶形边缘（roof edge）。 edges 图中每一个格点代表一个像素，格点在三维空间中的高低代表像素值（可能是灰度值，某一通道的像素值）的大小。可以看到图中的像素值变化剧烈，这即是图像中的边缘。而且可以注意到由于边缘的存在，这些图像是连续但不可微的。图中的矩形则表示局部优化滤波器在运算时所用的局部窗口（对应前文中的 $\\omega$）。由于通常的局部优化滤波器是取以当前像素为中心的正方形作为窗口 $\\omega$， 因此对于阶梯形边缘的情况，像素 $a$ 对应的窗口就是图中红蓝两个矩形的拼接。 下面[1]我们用 $g(x,y)$ 来代表在图像 $(x,y)$ 坐标处的原像素的值，易知在图中所示的边缘点附近，有 $$ g(x+\\epsilon, y) \\neq g(x-\\epsilon, y) $$ 或是 $$ g’(x+\\epsilon, y) \\neq g’(x-\\epsilon, y) $$ 如果在 $(x+\\epsilon, y)$ 和 $(x-\\epsilon, y)$ 处进行 Taylor 展开[2]，并分别代入 $x-2\\epsilon, x+2\\epsilon$ 易得 $$ g(x−2\\epsilon, y) \\approx g(x−\\epsilon, y) + \\frac{\\partial}{\\partial x} g(x−\\epsilon, y) \\cdot (−\\epsilon) $$ 和 $$ g(x+2\\epsilon, y) \\approx g(x+\\epsilon, y) + \\frac{\\partial}{\\partial x} g(x+\\epsilon, y) \\cdot \\epsilon $$ 以阶梯状边缘为例，结合上两式可以看到，点 $a$ 左侧点的像素值应该仅与 $a$ 左侧的点相关，$b$ 右侧的点的像素值也仅与 $b$ 右侧的点相关。再结合上文，由于一般的滤波器以当前像素为中心的正方形区域作为窗口，而在图像的边缘附近，这种方法不可避免地将不相关的一大部分像素点包括到计算之中，这样往往会造成边缘的像素发生扩散，显得非常模糊。 事实上我们可以调整窗口的大小，使其不再是一个完整的正方形，而是缩减为与当前像素点相关性更高的区域，例如在阶梯状边缘中，我们针对 $a$ 点就将窗口区域缩减为蓝色矩形，针对 $b$ 点就缩减为是红色矩形。这就是我们的侧边窗口滤波的思想。 ¶ Algorithm ¶ Core 这一章我们介绍核心算法。 传统的线性局部优化滤波器的窗口是一当前像素为中心的一个正方形，而在侧边窗口滤波算法中，窗口有八种选择（事实上不仅限于这八种，这个算法是容易被拓展的）。如下图所示， 12345┏━━━┯━━━┓┃ A │ B ┃┠───┼───┨┃ D │ C ┃┗━━━┷━━━┛ 我们将原先的正方形四等分为 $A, B, C, D$ 四个正方形，那么窗口的八种选择即 ${A, B, C, D, AB, BC , CD, DA }$ 。 算法将遍历八个窗口，最终选出一个窗口使得以下值最小 $$ E_i = \\frac{1}{N_A} (I_i - \\sum_{j \\in \\Omega_i} \\omega_{ij} q_j) ^ 2 $$ 其中 $N_A = \\sum_{j \\in {\\Omega_i}} \\omega_{ij}$ （这里 $\\frac{1}{N_A}$ 的作用是归一化）。 ¶ Analysis 由于我们的新算法只涉及对窗口的选取，所以很容易被附加到现有的一般算法上。 首先我们在盒子滤波（均值滤波 Box filter）上应用了我们的算法，然后在一些典型的样例上进行了测试。如下图所示，每三个横向的图片为一组测试。对于每一组中的三个图片，左起第一个为原灰度图像，中间为经过算法变换后的沿着过中心的横线的灰度变化图，右起第一个则为中间图像在红色方框处的放大后的图像。容易看到经过改进的盒子滤波更接近原图像的像素值，能更好的保留边缘（edge-preserving）。 analysis ¶ Evaluation 我们将侧边滤波算法部署到了现有的滤波算法上，并在不同的应用方面进行了实际测试。由于涉及方面过多，时间有限无法深入调研，下面仅进行简要描述并附上实验结果。 对于图中常用的算法缩写，解释如下： BOX 盒子滤波 均值滤波 GAU 高斯滤波 MED 中值滤波 BIL 双边滤波 GUI 导向滤波 guided filter ¶ 图像平滑 图像平滑用于减少图片的噪声或是产生锯齿较少的图片。大部分平滑化方法基于低通滤波器。 Smoothing is often used to reduce noise within an image or to produce a less pixelated image. Most smoothing methods are based on low pass filters.[3] image smoothing ¶ 图像去噪 image denoising ¶ 图像增强 图像增强的主要目的是处理给定的图像，以使结果比原始图像更适合特定的应用。它可以突出或锐化图像特征（例如边缘，边界或对比度），从而使图形显示更有助于展示和分析。增强功能不会增加数据的固有信息内容，但是会增加所选功能的动态范围，使得他们可以轻松被检测到。 The principal objective of image enhancement is to process a given image so that the result is more suitable than the original image for a specific application. It accentuates or sharpens image features such as edges, boundaries, or contrast to make a graphic display more helpful for display and analysis. The enhancement doesn’t increase the inherent information content of the data, but it increases the dynamic range of the chosen features so that they can be detected easily. [4] image enhancement ¶ HDR 色调映射 HDR 色彩映射指的是是将高动态范围成像（HDR）的图像映射到有限的范围（例如打印结果，LCD 显示器，投影仪）内。 hdr ¶ 在自然图像上保留结构和去除纹理 matual structure ¶ 相互结构提取 [5] structure preserving ¶ Colorization 图像上色是一种借助计算机给单色图像或电影添加颜色的过程。这个过程通常会将图像分割为多个区域并且在多个图像序列中追踪这些区域。 Colonization is a computer-assisted process of adding color to a monochrome image or movie. The process typically involves segmenting images into regions and tracking these regions across image sequences. [6] colorization ¶ Complexity Anylysis 显然，在应用侧边窗口算法后，时间复杂度的次数是不变的。但由于多遍历了几个子窗口，时间复杂度应当是原先的常数倍。具体地，我们对不同算法的时间复杂度进行了测试。实验环境为 包含有 1 Mega 像素的灰度图 3.5GHz Intel core Xeon® CPU 结果为 Method BOX GAU MED BIL GUI Original 0.052 0.023 1.16 8.69 0.131 SWF version 0.215 0.23 3.67 26.2 0.431 可以看到耗时为原先的2到10倍不等。 ¶ Conclusion 传统的图像处理算法将以像素为中心的正方形作为处理窗口，而我们指出这一取法并不是最优的，我们可以将窗口缩小为原先正方形的一个半边或是角落，从而提出侧边窗口滤波（SWF）。 许多流行的线性、非线性的滤波算法都可以很轻松地在侧边窗口滤波的基础上进行扩展，而且扩展后的算法能更好地保留边缘，提升性能，避免如颜色泄漏的伪像问题。 基于窗口的操作近些年来在计算机视觉、包括卷积神经网络在内的机器学习领域内被广泛使用。而 SWF 的一些原则，例如将操作窗口的边缘或是角落对齐到待操作像素，虽然看起来微不足道，但实际上扎根于许多算法的基本假设。我们的理论分析和在最新应用领域的实验都证明了其有效性。我们相信 SWF 原则会使更多的应用受益。 事实上，我认为原文中这一部分的说明不严谨，不够令人信服 ↩︎ 函数 $f$ 在 $a$ 点进行泰勒展开：$f(x) = \\sum_{n=0}^{\\infty} \\frac{f^{(n)}(a)}{n!} (x - a)^n$ ↩︎ https://caligari.dartmouth.edu/doc/idl/html_6.2/Smoothing_an_Image.html ↩︎ http://www.eie.polyu.edu.hk/~enyhchan/imagee.pdf ↩︎ http://www.cse.cuhk.edu.hk/leojia/projects/mutualstructure/index.html ↩︎ https://www.researchgate.net/publication/2896183_Colorization_using_Optimization ↩︎","categories":[],"tags":[{"name":"computer vision","slug":"computer-vision","permalink":"http://yoursite.com/tags/computer-vision/"},{"name":"denoise","slug":"denoise","permalink":"http://yoursite.com/tags/denoise/"},{"name":"filter","slug":"filter","permalink":"http://yoursite.com/tags/filter/"}]}],"categories":[],"tags":[{"name":"reinforcement learning","slug":"reinforcement-learning","permalink":"http://yoursite.com/tags/reinforcement-learning/"},{"name":"tcp","slug":"tcp","permalink":"http://yoursite.com/tags/tcp/"},{"name":"congestion control","slug":"congestion-control","permalink":"http://yoursite.com/tags/congestion-control/"},{"name":"computer vision","slug":"computer-vision","permalink":"http://yoursite.com/tags/computer-vision/"},{"name":"denoise","slug":"denoise","permalink":"http://yoursite.com/tags/denoise/"},{"name":"filter","slug":"filter","permalink":"http://yoursite.com/tags/filter/"}]}